extern crate oblivc;

// bindings generated by build.rs
include!(concat!(env!("OUT_DIR"), "/millionaire.rs"));

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::net::{TcpListener,TcpStream};
    use std::io::{Read,Write};

    #[test]
    fn test_millionaire() {
        // run server (party 1) in new thread
        let server = thread::spawn(|| {
            let mut args = millionaire_args {
                input: 10,
                output: 0,
            };
            let pd = oblivc::protocol_desc()
                .party(1)
                .accept("56734").unwrap();
            unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
        });
        // run client (party 2) in main thread
        let mut args = millionaire_args {
            input: 20,
            output: 0,
        };
        let pd = oblivc::protocol_desc()
            .party(2)
            .connect("localhost", "56734").unwrap();
        unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
        // wait for server to finish
        server.join().unwrap();
        // party 1 < party 2
        assert!(args.output == -1);
    }

    #[test]
    fn test_millionaire_stream() {
        let server = thread::spawn(|| {
            let mut args = millionaire_args {
                input: 10,
                output: 0,
            };
            let listener = TcpListener::bind("0.0.0.0:56735").unwrap();
            let (mut stream, _) = listener.accept().unwrap();
            stream.set_nodelay(true).unwrap();
            let pd = oblivc::protocol_desc()
                .use_stream(&mut stream)
                .party(1);
            unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
            stream.read_exact(&mut [0; 4]).unwrap();
            // run again with roles reversed
            let pd = oblivc::protocol_desc()
                .use_stream(&mut stream)
                .party(2);
            unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
        });
        let mut args = millionaire_args {
            input: 20,
            output: 0,
        };
        let mut stream = {|| { loop { match TcpStream::connect("localhost:56735") {
            Ok(s) => return s,
            Err(_) => thread::sleep(std::time::Duration::from_millis(100)),
        }}}}();
        stream.set_nodelay(true).unwrap();
        let pd = oblivc::protocol_desc()
            .party(2)
            .use_stream(&mut stream);
        unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
        assert!(args.output == -1);
        // we can use the same stream outside obliv-c
        stream.write_all(b"blah").unwrap();
        // use it for obliv-c again
        let pd = oblivc::protocol_desc()
            .party(1)
            .use_stream(&mut stream);
        unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
        assert!(args.output == 1);
        server.join().unwrap();
    }

    #[test]
    #[should_panic]
    fn test_no_party() {
        let mut args = millionaire_args {
            input: 0,
            output: 0,
        };
        let pd = oblivc::protocol_desc();
        unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
    }

    #[test]
    #[should_panic]
    fn test_no_trans() {
        let mut args = millionaire_args {
            input: 0,
            output: 0,
        };
        let pd = oblivc::protocol_desc().party(1);
        unsafe { pd.exec_yao_protocol(millionaire, &mut args); }
    }
}
